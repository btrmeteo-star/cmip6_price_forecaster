import os
import random
import joblib
import pandas as pd
from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates
from pydantic import BaseModel, Field
from typing import List, Dict, Any
from pathlib import Path

# ======================
# é…ç½®
# ======================
MODEL_DIR = "models"
SUPPORTED_CROPS = ["corn", "wheat", "rice"]  # å¯æ‰©å±•

# ======================
# Mock æ¨¡å‹ï¼ˆç”¨äºå…œåº•ï¼‰
# ======================
class MockModel:
    def predict(self, X: pd.DataFrame) -> List[float]:
        return [round(random.uniform(100.0, 300.0), 2) for _ in range(len(X))]

# ======================
# æ¨¡å‹ç¼“å­˜ï¼ˆé¿å…é‡å¤åŠ è½½ï¼‰
# ======================
model_cache: Dict[str, Any] = {}

def get_model(crop: str):
    if crop in model_cache:
        return model_cache[crop]

    model_path = Path(MODEL_DIR) / f"{crop}.joblib"
    if model_path.exists():
        try:
            model = joblib.load(model_path)
            model_cache[crop] = model
            print(f"âœ… æˆåŠŸåŠ è½½æ¨¡å‹: {model_path}")
            return model
        except Exception as e:
            print(f"âš ï¸ åŠ è½½æ¨¡å‹å¤±è´¥ {model_path}: {e}")
    
    # å›é€€åˆ° Mock
    print(f"ğŸ”„ ä½¿ç”¨ Mock æ¨¡å‹æ›¿ä»£: {crop}")
    model_cache[crop] = MockModel()
    return model_cache[crop]

# ======================
# FastAPI App
# ======================
app = FastAPI(
    title="CMIP6 å†œäº§å“ä»·æ ¼é¢„æµ‹ API",
    description="åŸºäºæ°”å€™ä¸å†å²ä»·æ ¼çš„å¤šä½œç‰©ä»·æ ¼é¢„æµ‹æœåŠ¡",
    version="1.0.0"
)

# å‰ç«¯æ¨¡æ¿
templates = Jinja2Templates(directory="templates")

# ======================
# æ•°æ®æ¨¡å‹
# ======================
FEATURE_COLUMNS = [
    "pr", "pr_lag1", "pr_lag2", "pr_std",
    "price_lag1", "price_lag2",
    "tasmax", "tasmax_lag1", "tasmax_lag2", "tasmax_mean"
]

class PredictionRequest(BaseModel):
    crop: str = Field(..., description="ä½œç‰©åç§°ï¼Œå¦‚ 'corn', 'wheat', 'rice'")
    pr: float = Field(..., description="å½“å‰é™æ°´é‡ (mm)")
    pr_lag1: float = Field(..., description="å‰1æœŸé™æ°´é‡")
    pr_lag1: float = Field(..., description="å‰1æœŸé™æ°´é‡")
    pr_lag2: float = Field(..., description="å‰2æœŸé™æ°´é‡")
    pr_std: float = Field(..., description="é™æ°´é‡æ ‡å‡†å·®")
    price_lag1: float = Field(..., description="å‰1æœŸä»·æ ¼")
    price_lag2: float = Field(..., description="å‰2æœŸä»·æ ¼")
    tasmax: float = Field(..., description="å½“å‰æœ€é«˜æ°”æ¸© (Â°C)")
    tasmax_lag1: float = Field(..., description="å‰1æœŸæœ€é«˜æ°”æ¸©")
    tasmax_lag2: float = Field(..., description="å‰2æœŸæœ€é«˜æ°”æ¸©")
    tasmax_mean: float = Field(..., description="æœ€é«˜æ°”æ¸©å‡å€¼")

class BatchPredictionRequest(BaseModel):
    crop: str = Field(..., description="ä½œç‰©åç§°ï¼ˆæ‰¹é‡æ ·æœ¬ç»Ÿä¸€ä½œç‰©ï¼‰")
    features_list: List[List[float]] = Field(
        ...,
        description=f"ç‰¹å¾åˆ—è¡¨ï¼Œæ¯ä¸ªå­åˆ—è¡¨åŒ…å« {len(FEATURE_COLUMNS)} ä¸ªç‰¹å¾å€¼"
    )

class PredictionResponse(BaseModel):
    crop: str
    predicted_price: float
    status: str = "success"

# ======================
# è·¯ç”±
# ======================

@app.get("/", response_class=HTMLResponse)
async def home(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})

@app.post("/predict", response_model=PredictionResponse)
async def predict_single(request: PredictionRequest):
    if request.crop not in SUPPORTED_CROPS:
        raise HTTPException(
            status_code=400,
            detail=f"ä¸æ”¯æŒçš„ä½œç‰©: {request.crop}ã€‚æ”¯æŒ: {SUPPORTED_CROPS}"
        )
    
    try:
        model = get_model(request.crop)
        features = [[
            request.pr, request.pr_lag1, request.pr_lag2, request.pr_std,
            request.price_lag1, request.price_lag2,
            request.tasmax, request.tasmax_lag1, request.tasmax_lag2, request.tasmax_mean
        ]]
        df = pd.DataFrame(features, columns=FEATURE_COLUMNS)
        pred = model.predict(df)[0]
        return PredictionResponse(crop=request.crop, predicted_price=float(pred))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"é¢„æµ‹å¤±è´¥: {str(e)}")

@app.post("/predict/batch", response_model=List[PredictionResponse])
async def predict_batch(request: BatchPredictionRequest):
    if request.crop not in SUPPORTED_CROPS:
        raise HTTPException(
            status_code=400,
            detail=f"ä¸æ”¯æŒçš„ä½œç‰©: {request.crop}ã€‚æ”¯æŒ: {SUPPORTED_CROPS}"
        )
    
    try:
        model = get_model(request.crop)
        df = pd.DataFrame(request.features_list, columns=FEATURE_COLUMNS)
        predictions = model.predict(df)
        return [
            PredictionResponse(
                crop=request.crop,
                predicted_price=float(pred),
                status="success"
            )
            for pred in predictions
        ]
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"æ‰¹é‡é¢„æµ‹å¤±è´¥: {str(e)}")

@app.get("/health")
async def health_check():
    return {"status": "ok", "model_cache": list(model_cache.keys())}
